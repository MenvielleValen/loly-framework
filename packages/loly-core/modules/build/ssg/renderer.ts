import fs from "fs";
import path from "path";
import { renderToString } from "react-dom/server";
import { loadChunksFromManifest, type LoadedRoute, type LoaderResult, type ServerContext } from "@router/index";
import {
  buildAppTree,
  buildInitialData,
  buildRouterData,
  createDocumentTree,
} from "@rendering/index";
import { pathToOutDir } from "./path";
import { ensureDir, getClientJsPath, getClientCssPath, loadAssetManifest } from "../utils";
import { STATIC_PATH } from "@constants/globals";

/**
 * Renders a static page for SSG.
 * 
 * Executes middlewares and loader, then renders the React component tree
 * to HTML. Writes both the HTML file and the data JSON file.
 * 
 * @param projectRoot - Root directory of the project
 * @param ssgOutDir - SSG output directory
 * @param route - Route definition
 * @param urlPath - URL path for this page
 * @param params - Route parameters
 * 
 * @example
 * await renderStaticRoute(
 *   '/project',
 *   '/project/{BUILD_FOLDER_NAME}/ssg',
 *   route,
 *   '/blog/my-post',
 *   { slug: 'my-post' }
 * );
 */
export async function renderStaticRoute(
  projectRoot: string,
  ssgOutDir: string,
  route: LoadedRoute,
  urlPath: string,
  params: Record<string, string>
): Promise<void> {
  const routeChunks = loadChunksFromManifest(projectRoot);
  const assetManifest = loadAssetManifest(projectRoot);
  const clientJsPath = getClientJsPath(projectRoot);
  const clientCssPath = getClientCssPath(projectRoot);
  
  // Get chunk href with hash if available
  const chunkName = routeChunks[route.pattern];
  let chunkHref: string | null = null;
  if (chunkName != null) {
    if (assetManifest && assetManifest.chunks[chunkName]) {
      chunkHref = `${STATIC_PATH}/${assetManifest.chunks[chunkName]}`;
    } else {
      chunkHref = `${STATIC_PATH}/${chunkName}.js`;
    }
  }

  // Mock request/response objects for SSG
  const req: any = {
    method: "GET",
    headers: {},
    query: {},
    path: urlPath,
  };

  const res: any = {
    statusCode: 200,
    headers: {} as Record<string, string>,
    setHeader(name: string, value: string) {
      this.headers[name.toLowerCase()] = value;
    },
    get headersSent() {
      return false;
    },
  };

  const ctx: ServerContext = {
    req,
    res,
    params,
    pathname: urlPath,
    locals: {},
  };

  // Execute middlewares
  for (const mw of route.middlewares) {
    await Promise.resolve(
      mw(ctx, async () => {
        /* no-op */
      })
    );
  }

  // 1. Execute layout server hooks (root â†’ specific) and collect props
  const layoutProps: Record<string, any> = {};

  if (route.layoutServerHooks && route.layoutServerHooks.length > 0) {
    for (let i = 0; i < route.layoutServerHooks.length; i++) {
      const layoutServerHook = route.layoutServerHooks[i];
      if (layoutServerHook) {
        try {
          const layoutResult = await layoutServerHook(ctx);
          // Merge props (more specific layouts override general ones)
          if (layoutResult.props) {
            Object.assign(layoutProps, layoutResult.props);
          }
        } catch (error) {
          // Log error but continue (layout server hook failure shouldn't break SSG)
          console.warn(`[framework][ssg] Layout server hook ${i} failed for route ${route.pattern}:`, error);
        }
      }
    }
  }

  // 2. Execute page server hook (getServerSideProps)
  let loaderResult: LoaderResult = { props: {} };

  if (route.loader) {
    loaderResult = await route.loader(ctx);
  }

  // 3. Combine props: layout props (stable) + page props (page overrides layout)
  const combinedProps = {
    ...layoutProps,
    ...(loaderResult.props || {}),
  };

  // Create combined loader result with merged props
  const combinedLoaderResult: LoaderResult = {
    ...loaderResult,
    props: combinedProps,
  };

  if (combinedLoaderResult.redirect || combinedLoaderResult.notFound) {
    return;
  }

  // Build React component tree with combined props
  const initialData = buildInitialData(urlPath, params, combinedLoaderResult);
  const routerData = buildRouterData(req);
  const appTree = buildAppTree(route, params, initialData.props);
  const documentTree = createDocumentTree({
    appTree,
    initialData,
    routerData,
    meta: loaderResult.metadata,
    titleFallback: "My Framework Dev",
    descriptionFallback: "Static page generated by @lolyjs/core.",
    chunkHref,
    clientJsPath,
    clientCssPath,
  });

  // Render to HTML (hydratable, same as SSR)
  const html = "<!DOCTYPE html>" + renderToString(documentTree);

  // Write files
  const dir = pathToOutDir(ssgOutDir, urlPath);
  ensureDir(dir);

  const htmlFile = path.join(dir, "index.html");
  const dataFile = path.join(dir, "data.json");

  fs.writeFileSync(htmlFile, html, "utf-8");
  fs.writeFileSync(dataFile, JSON.stringify(initialData, null, 2), "utf-8");
}

