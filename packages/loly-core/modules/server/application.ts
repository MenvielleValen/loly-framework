import http from "http";
import express from "express";
import cors from "cors";
import helmet from "helmet";
import cookieParser from "cookie-parser";
import compression from "compression";
import crypto from "crypto";
import { getServerConfig } from "@server/config";
import { createRateLimiter, createRateLimiterFromConfig } from "@server/middleware/rate-limit";
import { requestLoggerMiddleware, createModuleLogger } from "@logger/index";

interface SetupAppOptions {
  projectRoot: string;
}

export const setupApplication = async ({
  projectRoot,
}: SetupAppOptions): Promise<{
  app: express.Express;
  httpServer: http.Server<
    typeof http.IncomingMessage,
    typeof http.ServerResponse
  >;
}> => {
  const app = express();

  const serverConfig = await getServerConfig(projectRoot);

  const { bodyLimit, corsOrigin, rateLimit, security } = serverConfig;

  // Security: Helmet with configurable CSP
  const helmetConfig: any = {};

  if (security?.contentSecurityPolicy !== false) {
    // In development, allow unsafe-inline and unsafe-eval for hot reload
    if (process.env.NODE_ENV === "development") {
      helmetConfig.contentSecurityPolicy = {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: [
            "'self'",
            "'unsafe-inline'",
            "https://fonts.googleapis.com",
          ],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          imgSrc: ["'self'", "data:", "https:"],
          // Allow fetch/XHR to any HTTPS endpoint - users can restrict in their config if needed
          connectSrc: ["'self'", "ws:", "wss:", "https:"],
          fontSrc: ["'self'", "data:", "https://fonts.gstatic.com"],
        },
      };
    } else {
      // Use function-based CSP to enable nonce support in production
      const userCSP = security?.contentSecurityPolicy;
      const nonceFunction = (req: express.Request, res: express.Response) => {
        // Nonce is generated by middleware and stored in res.locals.nonce
        // This allows inline scripts with the nonce attribute
        const nonce = (res as any).locals?.nonce || "";
        return nonce ? `'nonce-${nonce}'` : "'self'";
      };

      const defaultCSP = {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: [
            "'self'",
            "'unsafe-inline'",
            "https://fonts.googleapis.com",
          ],
          scriptSrc: ["'self'", nonceFunction],
          imgSrc: ["'self'", "data:", "https:"],
          // Allow fetch/XHR to any HTTPS endpoint - users can restrict in their config if needed
          connectSrc: ["'self'", "https:"],
          fontSrc: ["'self'", "data:", "https://fonts.gstatic.com"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'", "https:"],
          frameSrc: ["'none'"],
        },
      };

      if (userCSP && typeof userCSP === "object" && !Array.isArray(userCSP)) {
        // Merge user CSP with default, but ensure scriptSrc includes nonce support
        const userDirectives = userCSP.directives || {};
        const mergedDirectives: any = {
          ...defaultCSP.directives,
          ...userDirectives,
        };

        // Ensure scriptSrc includes nonce support even if user provided custom scriptSrc
        const userScriptSrc = userDirectives.scriptSrc;
        if (userScriptSrc && Array.isArray(userScriptSrc)) {
          // Check if nonce function is already included
          const hasNonceSupport = userScriptSrc.some(
            (src) => typeof src === "function"
          );

          if (!hasNonceSupport) {
            // Add nonce function to user's scriptSrc
            mergedDirectives.scriptSrc = [...userScriptSrc, nonceFunction];
          } else {
            mergedDirectives.scriptSrc = userScriptSrc;
          }
        }

        // Ensure connectSrc includes https: for flexibility - merge arrays instead of replacing
        const userConnectSrc = userDirectives.connectSrc;
        if (userConnectSrc && Array.isArray(userConnectSrc)) {
          // If user provided connectSrc, merge with defaults to ensure https: is included
          const defaultConnectSrc = defaultCSP.directives.connectSrc || [];
          const mergedConnectSrc = [
            ...new Set([...defaultConnectSrc, ...userConnectSrc]),
          ];
          mergedDirectives.connectSrc = mergedConnectSrc;
        }

        // Ensure styleSrc includes Google Fonts
        const userStyleSrc = userDirectives.styleSrc;
        if (userStyleSrc && Array.isArray(userStyleSrc)) {
          const defaultStyleSrc = defaultCSP.directives.styleSrc || [];
          const mergedStyleSrc = [
            ...new Set([...defaultStyleSrc, ...userStyleSrc]),
          ];
          mergedDirectives.styleSrc = mergedStyleSrc;
        }

        // Ensure fontSrc includes Google Fonts
        const userFontSrc = userDirectives.fontSrc;
        if (userFontSrc && Array.isArray(userFontSrc)) {
          const defaultFontSrc = defaultCSP.directives.fontSrc || [];
          const mergedFontSrc = [
            ...new Set([...defaultFontSrc, ...userFontSrc]),
          ];
          mergedDirectives.fontSrc = mergedFontSrc;
        }

        helmetConfig.contentSecurityPolicy = {
          ...userCSP,
          directives: mergedDirectives,
        };
      } else {
        helmetConfig.contentSecurityPolicy = defaultCSP;
      }
    }
  } else {
    helmetConfig.contentSecurityPolicy = false;
  }

  // HSTS configuration
  if (security?.hsts !== false) {
    helmetConfig.hsts =
      security?.hsts === true
        ? { maxAge: 31536000, includeSubDomains: true }
        : security?.hsts;
  } else {
    helmetConfig.hsts = false;
  }

  // Generate nonce for CSP inline scripts (only in production)
  // In development, unsafe-inline is allowed
  // IMPORTANT: This must run BEFORE helmet so the nonce is available when CSP is evaluated
  if (
    process.env.NODE_ENV !== "development" &&
    security?.contentSecurityPolicy !== false
  ) {
    app.use(
      (
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
      ) => {
        // Generate a unique nonce for this request
        const nonce = crypto.randomBytes(16).toString("base64");
        (res.locals as any).nonce = nonce;
        next();
      }
    );
  }

  app.use(helmet(helmetConfig));

  // Logging: Request logger middleware (adds request ID and logs requests/responses)
  // Must be early in the middleware chain to capture all requests
  // Filters out static assets and other noisy paths by default
  const appLogger = createModuleLogger("framework");
  app.use(
    requestLoggerMiddleware({
      logger: appLogger.child({ component: "server" }),
      logRequests: process.env.LOG_REQUESTS === "true", // Default to false (only errors/warnings)
      logResponses: process.env.LOG_RESPONSES !== "false", // Default to true (but filtered)
      logStaticAssets: process.env.LOG_STATIC_ASSETS === "true", // Default to false
    })
  );

  // Security: CORS with proper origin validation
  const corsOptions: cors.CorsOptions = {
    credentials: true,
  };

  if (typeof corsOrigin === "function") {
    corsOptions.origin = corsOrigin;
  } else if (Array.isArray(corsOrigin)) {
    corsOptions.origin = corsOrigin.length > 0 ? corsOrigin : false;
  } else if (corsOrigin === true) {
    // Allow all origins (development only)
    corsOptions.origin = true;
  } else if (typeof corsOrigin === "string") {
    corsOptions.origin =
      corsOrigin === "*"
        ? process.env.NODE_ENV === "development"
          ? true
          : false
        : [corsOrigin];
  } else {
    // Default: no CORS in production, allow all in development
    corsOptions.origin = process.env.NODE_ENV === "development";
  }

  app.use(cors(corsOptions));

  // Security: Rate limiting
  // Apply rate limiting in production, or in development if explicitly enabled
  if (rateLimit) {
    // In development, only apply if explicitly configured (not just defaults)
    const shouldApply = process.env.NODE_ENV !== "development" || 
                       process.env.ENABLE_RATE_LIMIT === "true";
    
    if (shouldApply) {
      try {
        const generalLimiter = createRateLimiterFromConfig(rateLimit, false);
        
        if (generalLimiter) {
          // Apply general rate limiting to all routes
          app.use(generalLimiter);
          
          const logger = createModuleLogger("server");
          logger.info("Rate limiting enabled", {
            windowMs: rateLimit.windowMs ?? 15 * 60 * 1000,
            max: rateLimit.max ?? 100,
            apiMax: rateLimit.apiMax,
            strictMax: rateLimit.strictMax,
            strictPatterns: rateLimit.strictPatterns?.length ?? 0,
          });
        }
      } catch (error) {
        const logger = createModuleLogger("server");
        logger.error("Failed to setup rate limiting", {
          error: error instanceof Error ? error.message : String(error),
        });
        // Don't throw - continue without rate limiting rather than crashing
      }
    }
  }

  app.use(cookieParser());

  app.use(express.json({ limit: bodyLimit }));
  app.use(express.urlencoded({ extended: true, limit: bodyLimit }));

  app.use(compression());

  // Create http server
  const httpServer = http.createServer(app);

  return {
    app,
    httpServer,
  };
};
