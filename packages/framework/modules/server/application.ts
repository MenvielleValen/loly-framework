import http from "http";
import express from "express";
import cors from "cors";
import helmet from "helmet";
import cookieParser from "cookie-parser";
import compression from "compression";
import crypto from "crypto";
import { getServerConfig } from "@server/config";
import { createRateLimiter } from "@server/middleware/rate-limit";

interface SetupAppOptions {
  projectRoot: string;
}

export const setupApplication = async ({
  projectRoot,
}: SetupAppOptions): Promise<{
  app: express.Express;
  httpServer: http.Server<
    typeof http.IncomingMessage,
    typeof http.ServerResponse
  >;
}> => {
  const app = express();

  const serverConfig = await getServerConfig(projectRoot);

  const { bodyLimit, corsOrigin, rateLimit, security } = serverConfig;

  // Security: Helmet with configurable CSP
  const helmetConfig: any = {};
  
  if (security?.contentSecurityPolicy !== false) {
    // In development, allow unsafe-inline and unsafe-eval for hot reload
    if (process.env.NODE_ENV === "development") {
      helmetConfig.contentSecurityPolicy = {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'", "ws:", "wss:"],
          fontSrc: ["'self'", "data:"],
        },
      };
    } else {
      // Use function-based CSP to enable nonce support in production
      const userCSP = security?.contentSecurityPolicy;
      const nonceFunction = (req: express.Request, res: express.Response) => {
        // Nonce is generated by middleware and stored in res.locals.nonce
        // This allows inline scripts with the nonce attribute
        const nonce = (res as any).locals?.nonce || "";
        return nonce ? `'nonce-${nonce}'` : "'self'";
      };
      
      const defaultCSP = {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'", nonceFunction],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'"],
          fontSrc: ["'self'", "data:"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      };

      if (userCSP && typeof userCSP === "object" && !Array.isArray(userCSP)) {
        // Merge user CSP with default, but ensure scriptSrc includes nonce support
        const userDirectives = userCSP.directives || {};
        const mergedDirectives: any = {
          ...defaultCSP.directives,
          ...userDirectives,
        };
        
        // Ensure scriptSrc includes nonce support even if user provided custom scriptSrc
        const userScriptSrc = userDirectives.scriptSrc;
        if (userScriptSrc && Array.isArray(userScriptSrc)) {
          // Check if nonce function is already included
          const hasNonceSupport = userScriptSrc.some((src) => 
            typeof src === "function"
          );
          
          if (!hasNonceSupport) {
            // Add nonce function to user's scriptSrc
            mergedDirectives.scriptSrc = [
              ...userScriptSrc,
              nonceFunction,
            ];
          } else {
            mergedDirectives.scriptSrc = userScriptSrc;
          }
        }
        
        helmetConfig.contentSecurityPolicy = {
          ...userCSP,
          directives: mergedDirectives,
        };
      } else {
        helmetConfig.contentSecurityPolicy = defaultCSP;
      }
    }
  } else {
    helmetConfig.contentSecurityPolicy = false;
  }

  // HSTS configuration
  if (security?.hsts !== false) {
    helmetConfig.hsts = security?.hsts === true 
      ? { maxAge: 31536000, includeSubDomains: true }
      : security?.hsts;
  } else {
    helmetConfig.hsts = false;
  }

  // Generate nonce for CSP inline scripts (only in production)
  // In development, unsafe-inline is allowed
  // IMPORTANT: This must run BEFORE helmet so the nonce is available when CSP is evaluated
  if (process.env.NODE_ENV !== "development" && security?.contentSecurityPolicy !== false) {
    app.use((req: express.Request, res: express.Response, next: express.NextFunction) => {
      // Generate a unique nonce for this request
      const nonce = crypto.randomBytes(16).toString("base64");
      (res.locals as any).nonce = nonce;
      next();
    });
  }

  app.use(helmet(helmetConfig));

  // Security: CORS with proper origin validation
  const corsOptions: cors.CorsOptions = {
    credentials: true,
  };

  if (typeof corsOrigin === "function") {
    corsOptions.origin = corsOrigin;
  } else if (Array.isArray(corsOrigin)) {
    corsOptions.origin = corsOrigin.length > 0 ? corsOrigin : false;
  } else if (corsOrigin === true) {
    // Allow all origins (development only)
    corsOptions.origin = true;
  } else if (typeof corsOrigin === "string") {
    corsOptions.origin = corsOrigin === "*" 
      ? (process.env.NODE_ENV === "development" ? true : false)
      : [corsOrigin];
  } else {
    // Default: no CORS in production, allow all in development
    corsOptions.origin = process.env.NODE_ENV === "development";
  }

  app.use(cors(corsOptions));

  // Security: Rate limiting
  if (rateLimit) {
    const generalLimiter = createRateLimiter({
      windowMs: rateLimit.windowMs,
      max: rateLimit.max,
    });
    
    // Apply general rate limiting to all routes
    app.use(generalLimiter);
  }

  app.use(cookieParser());

  app.use(express.json({ limit: bodyLimit }));
  app.use(express.urlencoded({ extended: true, limit: bodyLimit }));

  app.use(compression());

  // Create http server
  const httpServer = http.createServer(app);

  return {
    app,
    httpServer,
  };
};
