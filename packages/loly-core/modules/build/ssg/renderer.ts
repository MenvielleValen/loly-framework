import fs from "fs";
import path from "path";
import { renderToString } from "react-dom/server";
import { loadChunksFromManifest, type LoadedRoute, type LoaderResult, type ServerContext } from "@router/index";
import {
  buildAppTree,
  buildInitialData,
  buildRouterData,
  createDocumentTree,
} from "@rendering/index";
import { pathToOutDir } from "./path";
import { ensureDir, getClientJsPath, getClientCssPath, loadAssetManifest } from "../utils";
import { STATIC_PATH } from "@constants/globals";

/**
 * Renders a static page for SSG.
 * 
 * Executes middlewares and loader, then renders the React component tree
 * to HTML. Writes both the HTML file and the data JSON file.
 * 
 * @param projectRoot - Root directory of the project
 * @param ssgOutDir - SSG output directory
 * @param route - Route definition
 * @param urlPath - URL path for this page
 * @param params - Route parameters
 * 
 * @example
 * await renderStaticRoute(
 *   '/project',
 *   '/project/{BUILD_FOLDER_NAME}/ssg',
 *   route,
 *   '/blog/my-post',
 *   { slug: 'my-post' }
 * );
 */
export async function renderStaticRoute(
  projectRoot: string,
  ssgOutDir: string,
  route: LoadedRoute,
  urlPath: string,
  params: Record<string, string>
): Promise<void> {
  const routeChunks = loadChunksFromManifest(projectRoot);
  const assetManifest = loadAssetManifest(projectRoot);
  const clientJsPath = getClientJsPath(projectRoot);
  const clientCssPath = getClientCssPath(projectRoot);
  
  // Get chunk href with hash if available
  const chunkName = routeChunks[route.pattern];
  let chunkHref: string | null = null;
  if (chunkName != null) {
    if (assetManifest && assetManifest.chunks[chunkName]) {
      chunkHref = `${STATIC_PATH}/${assetManifest.chunks[chunkName]}`;
    } else {
      chunkHref = `${STATIC_PATH}/${chunkName}.js`;
    }
  }

  // Mock request/response objects for SSG
  const req: any = {
    method: "GET",
    headers: {},
    query: {},
    path: urlPath,
  };

  const res: any = {
    statusCode: 200,
    headers: {} as Record<string, string>,
    setHeader(name: string, value: string) {
      this.headers[name.toLowerCase()] = value;
    },
    get headersSent() {
      return false;
    },
  };

  const ctx: ServerContext = {
    req,
    res,
    params,
    pathname: urlPath,
    locals: {},
  };

  // Execute middlewares
  for (const mw of route.middlewares) {
    await Promise.resolve(
      mw(ctx, async () => {
        /* no-op */
      })
    );
  }

  // Execute loader
  let loaderResult: LoaderResult = { props: {} };

  if (route.loader) {
    loaderResult = await route.loader(ctx);
  }

  if (loaderResult.redirect || loaderResult.notFound) {
    return;
  }

  // Build React component tree
  const initialData = buildInitialData(urlPath, params, loaderResult);
  const routerData = buildRouterData(req);
  const appTree = buildAppTree(route, params, initialData.props);
  const documentTree = createDocumentTree({
    appTree,
    initialData,
    routerData,
    meta: loaderResult.metadata,
    titleFallback: "My Framework Dev",
    descriptionFallback: "Static page generated by @lolyjs/core.",
    chunkHref,
    clientJsPath,
    clientCssPath,
  });

  // Render to HTML (hydratable, same as SSR)
  const html = "<!DOCTYPE html>" + renderToString(documentTree);

  // Write files
  const dir = pathToOutDir(ssgOutDir, urlPath);
  ensureDir(dir);

  const htmlFile = path.join(dir, "index.html");
  const dataFile = path.join(dir, "data.json");

  fs.writeFileSync(htmlFile, html, "utf-8");
  fs.writeFileSync(dataFile, JSON.stringify(initialData, null, 2), "utf-8");
}

